import General.utils as GU

GU.UPSTREAM_NT = 'TACCACTACTAGGCAAAGCATCACTGCTATGACAAATACGGGCGCATTTGGACAACAATCAGGGGCAGTGTATGTGGGGA'
GU.DOWNSTREAM_NT = 'AAGACATACACGAATCAATTAGATGGACCAAGGATCCAAAGAACACCCAAGATCACGTGCGCTCACTGTGTCTATTAGCTTGGCATAACGGGGAGCACGAATATGAGGAGTTCATCCGTAAAATTAGAAGCGTCCCAGTCGGACGTTGTTTGACCCTCCCCGCGTTTTCAACTCTACGCAGGAAATGGTTGGACTCCTTTTAGATTAGAGACAATTTGAAATAATTTAGATTGGCTTAACCCTACTGTGCT'

import time
import json
import tracemalloc
from pathlib import Path
import pandas as pd
import networkx as nx
from General.primer_graphs import create_primer_df, create_graph

from General.args import *
import sys



# ---------- helper utilities ----------
def rc(seq: str) -> str:
    tbl = str.maketrans("ACGTacgt", "TGCAtgca")
    return seq.translate(tbl)[::-1]

def find_unique(haystack: str, needle: str, prev_pos):
    """Return the 0-based index if needle occurs exactly once in haystack; else None."""

    p = haystack.find(needle, prev_pos)
    if p == -1:
        raise SystemExit(f"Primer {needle} not found!")
    return p


GELLER_PRIMERS = {
    1:  ("taccactactaggcaaagcatcact",           "ctcttggacctctactagacctgg"),
    2:  ("gcactacccaatttcgtttgaagga",           "ccgaatgcatttccaagctgttc"),
    3:  ("gaacagggagtgaaggactatgtg",            "cagccatagggattccgtaatattg"),
    4:  ("gtggctcaaacagaaggtgtca",              "gttcctggtcactttgggatgg"),
    5:  ("cacaatcgagcagagcgcg",                 "tttctcagcaagcgaccttcc"),
    6:  ("caagtcggtggcaacaaacttaatt",           "cggtgaggtgaacagaatgcc"),
    7:  ("catggctgccctagaagagaaa",              "aattgaccgggcaacactcatc"),
    8:  ("cccatgtcagtcaagacttgtgac",            "gtgcaacgctaattttgatctctct"),
    9:  ("caccgagatgtttagggagtacaat",           "ccactgacacaaatgtggtcaa"),
    10: ("ggctttcatttgcttacaggca",              "gcccacctgtcatagatgcc"),
    11: ("gaatatggcgagtttaccatgctg",            "gttgggaaacttgctggtgttaat"),
    12: ("ggttaatgaggcagtgctagca",              "caccttgctcatcattgaagtagtg"),
    13: ("cttctcagcagcactcctcaaa",              "gcgtagtggtccactgcttc"),
    14: ("acacgtggatgagtacatgctg",              "cttctctatggacctgagctcat"),
    15: ("cctgaacctaccaatggtgacttat",           "ccagacagggcttaagctagc"),
    16: ("agcatttgattactctgggtacgat",           "caccatatgcgatcatcctgaattg"),
    17: ("gtgtacaaagggattgacttggac",            "ttgattcgtgtatgtctttcatggg"),
    18: ("cttcctggtgcatcctgttatg",              "agcacagtagggttaagccaa"),
}


mutreg_nt = (
    "ACTACAGGGTGGTAAATAGACATCTAGCTACCAGTGCTGACTGGCAAAACTGTGTGTGGGAAAGTTACAACAGAGACCTCTTAGTGAGCACGACCACAGCACATGGATGTGATATTATAGCCAGATGTCAGTGCACAACGGGAGTGTACTTTTGTGCGTCCAAAAACAAGCACTACCCAATTTCGTTTGAAGGACCAGGTCTAGTAGAGGTCCAAGAGGCTGGTCTAGTAGAGGTCCAAGAGAGTGAATACTACCCCAGGAGATACCAATCCCATGTGCTTTTAGCAGCTGGATTTTCCGAACCAGGTGACTGTGGCGGTATCCTAAGGTGTGAGCATGGTGTCATTGGCATTGTGACCATGGGGGGTGAAGGCGTGGTCGGCTTTGCAGACATCCGTGATCTCCTGTGGCTGGAAGATGATGCAATGGAACAGGGAGTGAAGGACTATGTGGAACAGCTTGGAAATGCATTCGGGCTCAGCTTGGAAATGCATTCGGCTCCGGCTTTACTAACCAAATATGTGAGCAAGTCAACCTCCTGAAAGAATCACTAGTGGGTCAAGACTCCATCTTAGAGAAATCTCTAAAAGCCTTAGTTAAGATAATATCAGCCTTAGTAATTGTGGTGAGGAACCACGATGACCTGATCACTGTGACTGCCACACTAGCCCTTATCGGTTGTACCTCGTCCCCGTGGCGGTGGCTCAAACAGAAGGTGTCACAATATTACGGAATCCCTATGGCTGGCTTATTACGGAATCCCTATGGCTGAACGCCAAAACAATAGCTGGCTTAAGAAATTTACTGAAATGACAAATGCTTGCAAGGGTATGGAATGGATAGCTGTCAAAATTCAGAAATTCATTGAATGGCTCAAAGTAAAAATTTTGCCAGAGGTCAGAGAAAAACACGAGTTCCTGAACAGACTTAAACAACTCCCCTTATTAGAAAGTCAGATCGCCACAATCGAGCAGAGCGCGCCATCCCAAAGTGACCAGGAACGCTTCCCAAAGTGACCAGGAACAATTATTTTCCAATGTCCAATACTTTGCCCACTATTGCAGAAAGTACGCTCCCCTCTACGCAGCTGAAGCAAAGAGGGTGTTCTCCCTTGAGAAGAAGATGAGCAATTACATACAGTTCAAGTCCAAATGCCGTATTGAACCTGTATGTTTGCTCCTGCACGGGAGCCCTGGTGCCGGCAAGTCGGTGGCAACAAACTTAATTGGAAGGTCGCTTGCTGAGAAAGCTAGGTCGCTTGCTGAGAAACTCAACAGCTCAGTGTACTCACTACCGCCAGACCCAGATCACTTCGACGGATACAAACAGCAGGCCGTGGTGATTATGGACGATCTATGCCAGAATCCTGATGGGAAAGACGTCTCCTTGTTCTGCCAAATGGTTTCCAGTGTAGATTTTGTACCACCCATGGCTGCCCTAGAAGAGAAAGGCATTCTGTTCACCTCACCGGCAATTCTGTTCACCTCACCGTTTGTCTTGGCATCGACCAATGCAGGATCTATTAATGCTCCAACCGTGTCAGATAGCAGAGCCTTGGCAAGGAGATTTCACTTTGACATGAACATCGAGGTTATTTCCATGTACAGTCAGAATGGCAAGATAAACATGCCCATGTCAGTCAAGACTTGTGACGATGAGTGTTGCCCGGTCAATTGCAGAGTGTTGCCCGGTCAATTTTAAAAAGTGCTGCCCTCTTGTGTGTGGGAAGGCTATACAATTCATTGATAGAAGAACACAGGTCAGATACTCTCTAGACATGCTAGTCACCGAGATGTTTAGGGAGTACAATCATAGACATAGCGTGGGGACCACGCTTGAGGCACTGTTCCAGGGACCACCAGTATACAGAGAGATCAAAATTAGCGTTGCACAGAGAGATCAAAATTAGCGTTGCACCAGAGACACCACCACCGCCCGCCATTGCGGACCTGCTCAAATCGGTAGACAGTGAGGCTGTGAGGGAGTACTGCAAAGAAAAAGGATGGTTGGTTCCTGAGATCAACTCCACCCTCCAAATTGAGAAACATGTCAGTCGGGCTTTCATTTGCTTACAGGCATTGACCACATTTGTGTCAGTGGGCAACCACATTTGTGTCAGTGGCTGGAATCATATATATAATATATAAGCTCTTTGCGGGTTTTCAAGGTGCTTATACAGGAGTGCCCAACCAGAAGCCCAGAGTGCCTACCCTGAGGCAAGCAAAAGTGCAAGGCCCTGCCTTTGAGTTCGCCGTCGCAATGATGAAAAGGAACTCAAGCACGGTGAAAACTGAATATGGCGAGTTTACCATGCTGGGCATCTATGACAGGTGGGCGCAATCTATGACAGGTGGGCCGTTTTGCCACGCCACGCCAAACCTGGGCCAACCATCTTGATGAATGATCAAGAGGTTGGTGTGCTAGATGCCAAGGAGCTAGTAGACAAGGACGGCACCAACTTAGAACTGACACTACTCAAATTGAACCGGAATGAGAAGTTCAGAGACATCAGAGGCTTCTTAGCCAAGGAGGAAGTGGAGGTTAATGAGGCAGTGCTAGCAATTAACACCAGCAAGTTTCCCAACGCAAACACCAGCAAGTTTCCCAACATGTACATTCCAGTAGGACAGGTCACAGAATACGGCTTCCTAAACCTAGGTGGCACACCCACCAAGAGAATGCTTATGTACAACTTCCCCACAAGAGCAGGCCAGTGTGGTGGAGTGCTCATGTCCACCGGCAAGGTACTGGGTATCCATGTTGGTGGAAATGGCCATCAGGGCTTCTCAGCAGCACTCCTCAAACACTACTTCAATGATGAGCAAGGTGGCATACTTCAATGATGAGCAAGGTGAAATAGAATTTATTGAGAGCTCAAAGGACGCCGGGTTTCCAGTCATCAACACACCAAGTAAAACAAAGTTGGAGCCTAGTGTTTTCCACCAGGTCTTTGAGGGGAACAAAGAACCAGCAGTACTCAGGAGTGGGGATCCACGTCTCAAGGCCAATTTTGAAGAGGCTATATTTTCCAAGTATATAGGAAATGTCAACACACACGTGGATGAGTACATGCTGGAAGCAGTGGACCACTACGCGCTGCAGTGGACCACTACGCAGGCCAACTAGCCACCCTAGATATCAGCACTGAACCAATGAAACTGGAGGACGCAGTGTACGGTACCGAGGGTCTTGAGGCGCTTGATCTAACAACGAGTGCCGGTTACCCATATGTTGCACTGGGTATCAAGAAGAGGGACATCCTCTCTAAGAAGACTAAGGACCTAACAAAGTTAAAGGAATGTATGGACAAGTATGGCCTGAACCTACCAATGGTGACTTATGTAAAAGATGAGCTCAGGTCCATAGAGAAGATGAGCTCAGGTCCATAGAGAAGGTAGCGAAAGGAAAGTCTAGGCTGATTGAGGCGTCCAGTTTGAATGATTCAGTGGCGATGAGACAGACATTTGGTAATCTGTACAAAACTTTCCACCTAAACCCAGGGGTTGTGACTGGTAGTGCTGTTGGGTGTGACCCAGACCTCTTTTGGAGCAAGATACCAGTGATGTTAGATGGACATCTCATAGCATTTGATTACTCTGGGTACGATGCTAGCTTAAGCCCTGTCTGGAGGAGCTTAAGCCCTGTCTGGTTTGCTTGCCTAAAAATGTTACTTGAGAAGCTTGGATACACGCACAAAGAGACAAACTACATTGACTACTTGTGCAACTCCCATCACCTGTACAGGGATAAACATTACTTTGTGAGGGGTGGCATGCCCTCGGGATGTTCTGGTACCAGTATTTTCAACTCAATGATTAACAATATCATAATTAGGACACTAATGCTAAAAGTGTACAAAGGGATTGACTTGGACCAATTCAGGATGATCGCATATGGTGGCTTTCAGGATGATCGCATATGGTGATGATGTGATCGCATCGTACCCATGGCCTATAGATGCATCTTTACTCGCTGAAGCTGGTAAGGGTTACGGGCTGATCATGACACCAGCAGATAAGGGAGAGTGCTTTAACGAAGTTACCTGGACCAACGCCACTTTCCTAAAGAGGTATTTTAGAGCAGATGAACAGTACCCCTTCCTGGTGCATCCTGTTATGCCCATGAAAGACATACACGAATCAAGCAATGA"
)

sequence_nt = GU.UPSTREAM_NT + mutreg_nt + GU.DOWNSTREAM_NT


sys.argv = [
        sys.argv[0],
        "--file_path", "input_path",
        "--output", "output_path",
        ]

args = get_args()

args.oligo_lmin = 245
args.oligo_lmax = 255

t0 = time.time()

# ---- Build primer table and graph ----
primer_df = create_primer_df(sequence_nt, args)

competing_primers = []
missing = []

f_pos = 0 

for tile in sorted(GELLER_PRIMERS.keys()):
    fwd = GELLER_PRIMERS[tile][0].upper()
    rev = GELLER_PRIMERS[tile][1].upper()
    rc_rev = rc(rev)

    f_pos = find_unique(sequence_nt.upper(), fwd, f_pos) 
    r_pos = find_unique(sequence_nt.upper(), rc_rev, f_pos) 

    if f_pos is None:
        raise SystemExit(f"No sequence matched fwd primer {tile}!")
    else:
        competing_primers.append((f_pos - len(GU.UPSTREAM_NT), f_pos + len(fwd) - len(GU.UPSTREAM_NT), 'f'))

    if r_pos is None:
         raise SystemExit(f"No sequence matched rev primer {tile}!")
    else:
         competing_primers.append((r_pos - len(GU.UPSTREAM_NT), r_pos + len(rev) - len(GU.UPSTREAM_NT), 'r'))

print('All primers were found in sequence!')

geller_set = primer_df.loc[competing_primers].copy().reset_index()
geller_efficiency = float(geller_set['efficiency'].sum())

t_graph0 = time.time()
tracemalloc.start()
graph = create_graph(primer_df, len(mutreg_nt), args)
graph_time = time.time() - t_graph0
graph_peak_mb = tracemalloc.get_traced_memory()[1] / 1e6
tracemalloc.stop()

longest_path_t0 = time.time()

full_path = GU.longest_path_dag(graph, 's', 'd')
# strip s/d for primer nodes only (they should match primer_df index)
primer_path_nodes = full_path[1:-1]
# cost = sum of node weights as you stored them on edges entering those nodes
# but you already stored the per-primer cost in primer_df, so:
primer_set = primer_df.loc[primer_path_nodes].copy().reset_index()
primer_efficiency = float(primer_set['efficiency'].sum())

longest_path_time = time.time() -longest_path_t0

total_time = time.time() - t0


# ---- CSV (no path in CSV) ----
row = {
    "graph_nodes": len(graph.nodes),
    "graph_edges": len(graph.edges),
    "graph_time_sec": round(graph_time, 3),
    "graph_peak_mem_MB": round(graph_peak_mb, 1),
    "PD_single_efficiency": primer_efficiency,
    "Geller_efficiency": geller_efficiency,
    "PD_single_primers":len(primer_path_nodes),
    "QuickChange_primers":len(competing_primers),
    "shortest_path_time": longest_path_time,
    "total_time_sec": round(total_time, 3)
}
df = pd.DataFrame([row])

out_base = Path("Geller_method_comparison")
out_base.parent.mkdir(parents=True, exist_ok=True)
csv_path = out_base.with_suffix(".csv")
df.to_csv(csv_path, index=False)



